export const metadata = {
  title: "软件设计的哲学 A Philosophy of Software Design",
  date: "2025-08-03",
  tag: ["design", 'programming'],
  description: "这是一篇来源于软件设计的哲学的阅读笔记，这本书深入探讨了软件设计中的核心问题：如何将复杂的软件系统分解为可以相对独立实现的模块（例如类和方法），从而降低其复杂性并提高开发效率。",
  duration: '60min'
}

# 软件设计的哲学 A Philosophy of Software Design

[软件设计的哲学](https://book.douban.com/subject/37119755/)([在线阅读](https://cactus-proj.github.io/A-Philosophy-of-Software-Design-zh/ch01.html)) 围绕软件**复杂性**展开，探讨其本质、成因及解决策略，核心目标是通过合理设计最小化软件复杂性，使系统更易于理解和维护。

在任何程序的生命周期中，复杂性都会不可避免地增加。程序越大，工作的人越多，管理复杂性就越困难。有两种解决复杂性的通用方法，这两种方法都将在本书中进行讨论。
- 第一种方法是通过**使代码更简单和更明显**来消除复杂性。例如，可以通过消除特殊情况或以一致的方式使用标识符来降低复杂性：
- 解决复杂性的第二种方法是**封装它**，以便程序员可以在系统上工作而不会立即暴露其所有复杂性。这种方法称为**模块化设计**。这些模块被设计为彼此相对独立（低耦合），**以便程序员可以在一个模块上工作而不必了解其他模块的细节**。

理解这些方法的最佳方法是**与代码审查结合使用**。阅读其他人的代码时，请考虑它是否符合此处讨论的概念，以及它与代码的复杂性之间的关系。**在别人的代码中比在您的代码中更容易看到设计问题**。

## 复杂性是什么

学习如何设计软件系统以最小化其复杂性。第一步是了解敌人。究竟什么是“复杂性”？您如何判断系统是否过于复杂？是什么导致系统变得复杂？

### 复杂性的定义

> Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system
> 

**复杂性是指那些让系统难以理解或修改的与系统相关的任何事物**。

![Overall Complexity of a systems](/design/overall-complexity-of-a-systems.png)
可以采用粗略的数学方法表示：系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。

**如何判断一个系统的复杂性？**

一个简单的判断方式：如果一个软件系统难以理解和修改，那就很复杂。如果很容易理解和修改，那就很简单。假如要实施甚至很小的改进都需要大量的工作，那这个系统就很复杂。

> 注意：阅读代码（读者）的判断更为重要，如果您编写了一段代码，对您来说似乎很简单，但是其他人则认为它很复杂，那么它就是复杂的。

### 复杂性的症状

下面讲述几种使系统复杂的症状表现：

1. **变更放大（Change amplification）**：代码需要很多不同地方进行代码修改。

例如：下述改一个背景颜色，(a) 需要改四个地方

2. **认知负荷（Cognitive load）**：代码修改需要开发人员花很多时间学习很多知识才能完成。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息，并且由于错过了重要的东西而导致错误的风险也更大。

例如，假设 C 中的一个函数分配了内存，返回了指向该内存的指针，并假定调用者将释放该内存。这增加了使用该功能的开发人员的认知负担。如果开发人员无法释放内存，则会发生内存泄漏。

> 注意：系统设计人员有时会假设可以通过代码行来衡量复杂性。但是，这种观点忽略了与认知负荷相关的成本。有时，需要更多代码行的方法实际上更简单，因为它减少了认知负担。**所以复杂性并不能从代码行数简单地衡量**。

3. **未知的未知（Unknown unknowns）**：开发人员无法“显而易见”地了解需要修改哪些代码、获得哪些信息，才能完成任务。

例如：图 2.1 (c) 说明此问题。网站用中心变量确定横幅背景色，看似易改。但部分网页用较暗背景色强调，且各页面明确指定该颜色。若背景色改变，强调色须改变以匹配。
不幸的是，开发人员可能意识不到，会更改中央 bannerBg 变量而不更新强调色。即便意识到，也不清楚哪些页面用了强调色，可能得搜索网站每个页面。

> 注意：这种未知的未知是最可怕的，前 2 种只是增加成本，这种唯一的解决方式只有阅读所有的代码，修改代码困难而有风险。

![symptoms-of-complexity](/design/symptoms-of-complexity.png)
在（a）中，横幅的背景色在每页中都明确指定。在（b）中，共享变量保留背景色，并且每个页面都引用该变量。在（c）中，某些页面会显示其他用于强调的颜色，即横幅背景颜色的暗色；如果背景颜色改变，则强调颜色也必须改变。

### 复杂性的原因

复杂性主要由依赖性和模糊性引起的。

1. **依赖性**：当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。依赖关系是软件的基本组成部分，无法完全消除。依赖性导致变化放大和高认知负荷。
2. **模糊性**：当重要的信息不明显时，就会发生模糊。很多情况会导致系统模糊，如依赖关系存在不明显、文档/注释不足、不一致性等。这个也是引入“未知的未知”的原因。

**因此，如果我们找到最小化依赖关系和模糊性的设计技术，那么我们就可以降低软件的复杂性。**

### 复杂度是递增的

复杂性不是由单个灾难性错误引起的，它堆积成许多小块。单个依赖项或模糊性本身不太可能显着影响软件系统的可维护性。
之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖性和模糊性逐渐形成。最终，这些小问题太多了，以至于对系统的每次可能更改都会受到其中几个问题的影响。

作为开发人员很容易说服自己，当前引入的复杂性影响不大，但是日积月累，并且每个人员都这么做就会导致系统复杂性迅速累积。

为了减缓复杂性的增长，必须采用“零容忍”理念，**长期且坚定**地减缓复杂性的增长。

## 复杂性应对心态

### 战略编程

成为一名优秀的软件设计师的第一步是要意识到**能跑起来的的代码是不够的**。这里会提到概念叫“战术编程”和“战略编程”。

- **战术编程（tactical programming）**：不会花费时间做设计，重点是快速让某个功能/修改生效。<br/>
    问题：战术编程的问题是它是短视的。如果您是战术编程人员，那么您将尝试尽快完成任务。也许您有一个艰难的期限。因此，为未来做计划不是优先事项。您不会花费太多时间来寻找最佳设计。您只想尽快使某件事起作用。<br/>
    如果您进行战术编程（如果编码时总是使用战术式思维方式），则每个编程任务都会带来一些此类复杂性。为了快速完成当前任务，**他们每个人似乎都是一个合理的折衷方案**。但是，复杂性迅速累积，尤其是如果每个人都在战术上进行编程的时候。
- **战略编程（strategic programming）**：必须花费时间来改进系统的设计，而不是采取最快的方式来完成当前的项目。
    优势：战略性编程需要一种投资心态，这些投资会在短期内让您放慢脚步，但从长远来看会加快您的速度。<br/>
    但是，无论您预先投入多少，设计决策中都不可避免地会出现错误。随着时间的流逝，这些错误将变得显而易见。发现设计问题时，不要只是忽略它或对其进行修补。花一些额外的时间来修复它。

往往大多数开发人员会采用“战术编程”的方式，但是这种方式在不断地增加复杂性，这些复杂性将来会引起更严重的问题，可能需要花更多时间去处理。



### 长期心态

但是，用“战略编程”的方式必然引入开发成本，我们也需要考虑以什么方式更好地应对：这里的答案就是用**长期心态**去应对它。

**那么应该投资多少？**

大量的前期投资（例如尝试设计整个系统）将不会有效。最好的方法是连续进行大量小额投资 ​​。我建议您将总开发时间的 10％到 20％用于投资。
该金额足够小，不会对您的日程安排产生重大影响，但又足够大，可以随着时间的推移产生重大收益。

![tactical programming vs strategic programming](/design/tactical-programming-vs-strategic-programming.png)

如上图，一开始，战术性的编程方法将比战略性方法更快地取得进展。但是随着时间的流逝，战略编程会带来更大的进步。而且长期的“战术编程”可能会导致恶性循环，代码库的糟糕导致优秀工程师的流失，优秀工程师的流失导致代码库更加糟糕。

所以，我们需要**始终如一**使用长期心态（“战略心态”）应对复杂性，每个工程师在每次修改代码的时候都需要进行对于系统设计的投入（**连续的少量投入**），这样我们才能获得一个复杂性较低的系统。

## 降低复杂性的方法

上述主要讲述复杂性的定义和应对心态，下面讲述应对复杂性的一些原则和方法。

### 设计“深模块”

**“深模块（Deep Module）”**：最好的模块设计是那些提供强大功能但具有简单接口的模块。

如图，左边用简单的接口提供了复杂的功能，就代表这个模块很深。

Unix 提供的 IO 机制就是一个例子，文件系统是尤其复杂的，这么多年，系统内核发生了很多变化，但是这 5 个内核调用都没有发生变化。

```
int open(const char* path, int flags, mode_t permissions);
ssize_t read(int fd, void* buffer, size_t count);
ssize_t write(int fd, const void* buffer, size_t count);
off_t lseek(int fd, off_t offset, int referencePosition);
int close(int fd);

```

浅模块：浅层模块是其接口与其提供的功能相比接近的模块。

```
private void addNullValueForAttribute(String attribute) {
    data.put(attribute, null);
}

```

如图，其实这个接口封装增加了系统复杂性（文档更长、代码更长、还需要学习）。

下面讲述几种设计“深模块”的关键点：

**规避“信息泄漏”**

这里会提到两个概念，“信息隐藏”和“信息泄漏”。

“信息隐藏”和深层模块密切相关，如果模块隐藏了很多信息，则往往会增加模块提供的功能，同时还会减少其接口。这使模块更深。如上述 unix IO 接口通过抽象屏蔽了很多复杂的操作系统信息。

它的反面是“信息泄漏”，有两种体现方式：

1. **接口泄漏**：如修改一个功能需要影响多个模块，你把相关信息知识暴露在接口调用中，这里就叫“Interface leakage”。
2. **后门泄漏**：如有一个类写文件，一个类读文件，他们依赖相同的文件格式，如果文件格式修改，两个类都需要修改，这就是“Back-door leakage”。这种更严重，会引起“未知的未知”。

这里会提到几种原则：

1. **避免“时间分解”设计风格**。在设计模块时，应专注于执行每个任务所需的知识，而不是任务发生的顺序。
    
    如，有一个应用程序，以特定格式读取文件，修改文件内容，然后再次将文件写出。按时间分解，很容易设计三个类，这将导致信息泄漏（文件格式多次出现），但是理论上读写文件的机制应该在同一个模块
    
2. **组合相关功能的代码**。组合功能可以简化接口，减少“接口泄漏”。
    
    > 类并不是越多越好
    > 
3. **使常见情况尽可能简单**。可以尝试更多设计默认值，无需明确要求，模块就应该做正确的事情。如之前提到的例子有一个接口分配了内存，理论上它可以默认自动释放内存，调用者不用感知内存释放的存在。

**多设计通用模块**

通用模块通常相比专用模块接口更简单，更深入。一般可以问自己几个问题：

- **满足我当前所有需求的最简单的接口是什么？**

需要尽可能设计通用、简单的接口，减少接口数量。

> 注意：参数数量也是复杂度，减少接口数量和增加参数数量没有太大区别
> 
- **在多少情况下会使用此方法？**

假如专门为特殊用途设计的，需要再思考下它有没有必要。因为它会增加系统复杂性。

### 设计有不同抽象的层

假如系统中存在两个有相似抽象的层，那意味着类/模块的拆解有问题。

如上图

(a): C1 是一个不好的设计，它做了大量的透传方法。

(b)(c)(d) 是几种解法，解决这种透传方法导致的职责重复。

但是有相同签名的方法是不好的吗？并不是的。比如调度器，相同签名调度到不同实现。

所以判断原则就是**每种新方法都应贡献必要的功能**，直接透传方法是糟糕的。

跨层 API 重复还有一种表现，就是传递变量。

如上图（a)，cert 在中间并用不上，增加了系统的复杂性。

(b)(c)(d) 是提供的可选的解决方案，相比之下，上下文是相对更好的方式（虽然它也会带来一些问题，比如带来了不明显的依赖关系，导致线程安全等，但是假如是个上下文是个不变量就能规避较多问题）。

更与其说本节叫“设计有不同抽象的层”也可以叫做“**引入有意义的代码**。我们需要知道，添加到系统中的每一个设计基础设施，如接口、参数、函数、类或定义，都会增加复杂性，因为开发人员必须了解这个元素。所以不管是抽象层还是变量，都需要考虑到到你需要有收益，你才加入，否则无法对抗复杂性的增益。

### 做好代码拆分和合并

软件设计有一个基础的问题：代码应该写在一起还是分开写？

这里提供了基础的判断原则：

1. **以降低系统的复杂性（改善模块化）为目标**。“分开写”去设计更多小组件，并不是最佳选择，可能产生分离/重复，接口太多也会增加复杂性。
2. **如果信息共享，可以放到一起**。比如特定文件读取和写入，或者必须了解到另一个模块的实现才能了解当前模块的代码的实现，他们一般是需要放在一起。
3. **如果可以简化接口，可以放到一起**。比如本来要调用两个类，现在一个类就做到了。这个我们上面有提到，这将使模块更深。

这里涉及一定要拆分还有一个观点是：方法行数不能超过 X 行。但是，其实长方法不一定是坏的。我们可以看下面的例子。

如图（a) 是聚合在一起的方法

（b）拆分了子方法，如果子方法是独立的子任务，并且父方法和子方法完全信息分离（不需要互相了解），拆分是好的，假如做了拆分后，发现经常需要跳转过来看子方法的实现，那就不是好的拆分。

（c）拆分为 2 个方法，如果调用者必须同时调用这两个接口，那这个拆分是不好的。

（d）拆分了多个方法和层级，会导致接口复杂度大大增加，这个是应该避免的。

整体来说，**拆分或合并的决定应基于复杂性**。选择一种结构，它可以最好的隐藏信息，产生最少的依赖关系和最深的模块。

### 通过定义规避错误

软件中对异常的处理，往往会增加软件的复杂性，需要编写很多代码处理异常，比如异常上报、中断、重试等。

在编写模块接口的时候，很容易想到的就是，我把错误抛出去，让调用者处理就行了。但是其实这种想法，是把复杂性转移了，假如开发接口的人都处理不了的话，调用者基本也很难处理。

所以最好的方式就是设计好接口，让它没有异常可以处理，也就是第一种方式，**通过定义规避错误**。

这里有一个很典型的例子：

对于文件系统，Windows 操作系统不允许删除文件（如果已在进程中打开文件），为了删除正在使用的文件，用户必须在系统中搜索以找到已打开文件的进程，然后终止该进程，这个很令开发者头疼。但是 Unix 操作系统这块就做得很好，假如当前有进程在使用时，它并不会抛出异常，而是做了标记，等到所有访问进程都关闭了文件，便释放其数据。

第二种处理异常的方式就是**屏蔽异常**。如，TCP 在其实现中通过重新发送丢失的数据包来掩盖数据包的丢失，因此所有数据最终都将送达，并且客户端不会察觉到丢失的数据包。

第三种方式是**做好异常聚合**。

如上图，右侧的代码就是做好了异常的聚合处理。不过这里比较重要的需要做好异常分级，需要判断好哪些异常可以一起处理不会影响到系统的恢复。

第四种方式是**使应用程序崩溃**。这种是最粗暴的方式，通常出现在很少发生，并且错误很难处理的情况。常见的情况比如“内存不足”等，处理这些问题复杂性相当高，收益较低，这个可以根据实际情况去做取舍。

总而言之，我们需要通过设计减少异常，假如必须要抛出异常，需要抛出有意义的异常，这样整体才能降低系统复杂性。

### 多次设计

我们需要知道，第一次设计系统比较难产出最佳的设计。所以假如想要获得更好的结果，最好多思考设计两遍。

怎么进行多次设计呢？

每次做系统设计的时候，尝试选择不同的方案，并列出它们的优缺点（不管第二个方案有多糟糕，因为了解它的弱点将对你的方案很有启发）。然后可以问自己几个问题（当然可以更多）：

1. **还有更简单的方式吗？**（从复杂性角度思考）
2. **这个实现足够通用吗？**
3. **这个实现更有效率吗？**

这不仅能改善设计（降低系统复杂性），还能提高代码设计的能力。

### 写好注释

代码注释/文档是非常重要的。没有注释的话，无法隐藏复杂性。

**误区**

大家一般会以几个理由不写注释：

- 我的代码写得很好，不用注释了：注释是抽象的基础。如果调用人员必须阅读代码才能调用接口，意味着这个接口无抽象可言。
- 我没有时间写注释：同样的上面章节我们提到“长期心态”。好的注释对软件的可维护性有很大的影响。其实占用时间很少。
- 注释会过时，产生误导：这个取决于注释的写法（关键的思想是避免重复的文档，并保持文档和代码保持相近）

注释没有意义：这个确实存在，关键点在于我们需要写有意义的注释。

文档和注释能够解决复杂性的问题（包含上述提到的“认知负荷”和“未知的未知”），理清依赖关系和消除模糊性。

**怎么做**

下面，主要讲述怎么写好注释。

- **应该描述代码不明显的内容**：很容易造成的误区是，表述了一段代码的含义，这个是完全没有意义的。注释内容包含两种：
    - Low-level comment：讲述变量的单位 / 边界条件等（这将帮助调用者不用阅读代码才能了解内部信息）
    - Higher-level comment：帮助调用者理解了代码的整体意图和结构。
- **将注释 / 文档放在代码附近**：注释离其关联的代码越远，正确更新的可能性就越小。
- **注释优先于代码**：这样才会产生更好的注释，你在设计过程中不断改进注释。一旦延迟，随着代码变多，这些工作的吸引力就会越来越少。
- **避免重复注释 / 文档**：重复的注释或者重复的文档往往会导致它们一般是陈旧的。

### 保持系统的一致性

系统的一致性也是降低复杂性重要的工具。将帮助开发人员更快地以更少的错误，使用相似的工作方式完成任务。

一致性体现有以下几个例子：

1. 命名：命名的一致将帮助系统开发人员了解相关的概念。（领域驱动设计中就有这样的理念）
2. 编程样式：也就是代码风格指南
3. 接口：接口一致，实现不一致
4. 设计模式：一致的设计模式将更容易被接受

**如何确保一致性呢？**

1. **约定**：就是规范文档
2. **执行落地**：有规范并不够，需要看落地的情况
    1. **配套工具**，比如 Lint 工具等保障代码检查
    2. **做好代码审查**，代码审阅者越挑剔，团队中的每个人都将更快地学习约定，并且代码越干净。
    3. **尽量不要更改现有约定 When in Rome, do as the Romans do.** 最好参考示例的行为，假如你需要引入不一致的行为，思考几个问题：
        1. 旧方法是否无法满足？
        2. 新的方法是否好得多，值得花时间更新旧方法？
        3. 组织是否确定接受？

总之，保持一致性也是非常重要的，需要在日常的规范、自动检查工具、代码审查中帮助大家达成共识，进而能够降低系统复杂性，以更少的错误来更快地工作。

## 总结

上述就是本次分享的整体内容，一切都围绕着“复杂性”展开。成为一个优秀的软件工程师是需要在软件设计上面花费（投资）更多的时间，改善系统的复杂性，否则将在花大量时间在复杂的系统中寻找错误。

我觉得假如其他信息都忘了的话，可以记住以下几点：

1. 复杂性是递增的，添加到系统中的每一个设施都会增加复杂性，所以都需要考虑对于系统复杂性的影响。
2. 需要始终如一地投入降低复杂性，将很快获得回报。
3. 软件的设计应该是易于阅读而不是易于编写。